Предварительно создал виртуальную среду в анаконде.
Написал 4 простых теста для тестирования входного датафрейма.
Чтобы указать, что проверяется используется assert
Я придумал очень простой, пример, чтобы на нем постепенно показать, как использовать test
Видим, что у нас 4 раза загружается для теста датафрейм.
А как нам запустить только отдельный тест?
А если мы дальше будем масштабироваться, на сколько это все будет читаемо?
А что если у нас будет 50 тестов, как быть с ними?

Есть библиотека pytest, которая поможет решить сложности, которые могут возникнуть с увеличением количества тестов
Несколько слов про pytest.
... добавить немного описания из книги...
Он уже интегрирован в PyCharm
Чтобы библиотека поняла, что в файлах есть тесты, в них должно содержаться слово test и в названиях классов и функцйи тоже
Давайте запустим и посмотрим, на результат.

Сейчас я буду добавлять по одной возможности библиотеки и показывать как ими пользоваться
1. Маркеры
Они нужны для того, чтобы группировать тесты. Чтобы добавить маркер нужно импортировать библиотеку pytest и добавить декоратор
Таких декораторов может быть много.
Каждый из маркеров нужно определить в файле pytest.ini и через двоеточие описать зачем они нужны.
Давайте вызовем их по очереди

Следующая опция это fixture
Fixtures — это функции, выполняемые pytest до (а иногда и после) фактических тестовых функций. Код в фикстуре может делать все, что вам необходимо. Вы можете использовать Fixtures, чтобы получить набор данных для тестирования. Вы можете использовать Fixtures, чтобы получить систему в известном состоянии перед запуском теста. Fixtures также используются для получения данных для нескольких тестов.
Мы можем вынести в фикстуру функцию load_df
Чтобы обозначить фикстуру используем декоратор @pytest.fixture()
И теперь мы можем передавать эту функцию в качестве аргумента другим тестам

Есть опция  pytest --setup-show которая показывает в какой последовательности будут запускаться тесты:
pytest --setup-show test_func_fixtures.py
Как мы видим, для каждой проверки мы запускаем load_df, что не эффективно.
SETUP -
TEARDOWN -
Фикстуры включают в себя необязательный параметр под названием scope, который определяет, как часто фикстура получает setup и teardown. Параметр scope для @pytest.fixture() может иметь значения функции, класса, модуля или сессии. Scope по умолчанию — это функция. фикстуры пока не определяют область, Таким образом, они являются функциональными фикстурами.

Ниже приведено краткое описание каждого значения Scope:

   scope='function'
   Выполняется один раз для каждой функции теста. Часть setup запускается перед каждым тестом с помощью fixture. Часть teardown запускается после каждого теста с использованием fixture. Это область используемая по умолчанию, если параметр scope не указан.

   scope='class'
   Выполняется один раз для каждого тестового класса, независимо от количества тестовых методов в классе.

   scope='module'
   Выполняется один раз для каждого модуля, независимо от того, сколько тестовых функций или методов или других фикстур при использовании модуля.

   scope='session'
   Выполняется один раз за сеанс. Все методы и функции тестирования, использующие фикстуру области сеанса, используют один вызов setup и teardown.

Вот так это выглядит в действии:
Запустить файл test_scope
Видим, что есть буквы S, M, C это соответствие фикстурам
Для совместного использования фикстур в нескольких тестовых файлах лучше использовать файл conftest.py где-то в общем месте, централизованно для всех тестов

Давайте вынесем load_df из нашего файла в conftest.py и добавим в фикстуру load_df scope='session'
Еще раз запустим --setup-show и у нас уже всего один раз запускается загрузка датафрейма

Запустим проверку.
И видим, что у нас 2 теста упало с ошибкой.
pytest довольно информативно показывает, почему упали тесты, но давайте разбираться с каждым тестом по очереди.
Чтоб запустить еще раз один конкретный тест, который упал, просто указываем его через ::
pytest test_func_fixtures.py::test_find_duplicates -vv
pytest умеет подсказывать, где именно ошибка.
Для этого нужно добавить ключик -v
Давайте уберем вывод лишнего и оставим только саму ошибку используя --tb=short:
pytest --tb=short test_func_fixtures.py::test_find_duplicates -v

Допустим, что мы это исправили, запустили тест и он снова упал, но на следующем тесте.
Мы понимаем, о чем идет речь и устраняем эту ошибку. И смотрим на результат

Для отображения:
--last-failed или -lf
--failed-first или -ff

Посмотрим, что все тесты прошли успешно
pytest -v --tb=no test_func_fixtures.py


PASSED это значит что тест пройден. И время его прохождения
Показать:
1. Запуск только с того места где упали
2. Опцию -vv
3. Показать запуск только одного теста с ::

pytest --fixtures
pytest -k "MyClass and notmethod"
pytest --tb=short (есть много разных)
--durations=N - сообщает самый медленный N номер теста
--durations=0 выведет теты в порядке от самого медленного к самому быстрому
pytest --durations=4 --vv test_func_fixtures.py

Есть еще много всяких дополнительных опций, которые не стал освещать
Например, настройка фикстур. Например, использование кеша, изменение поведения функций и т.д.
Создание собственных плагинов. Например, плагин pytest-cov. Они доступны для установки из pip.
Можем создавать плагины сами.
Можем настраивать конфигурацию pytest под себя. pytest.ini conftest.py
Использование с другими библиотеками. pdb:Debugging Test Failures, pytest-cov, mock, tox, Jenkins
Ссылка на статьи есть в телеграмме